# Socket实现令牌环

### Author：Roser Han

#### Location：Shandong Linyi

[TOC]

## 模拟要求

1. 一共8台主机，通过进程来模拟，主机号可以手动输入。
2. 产生一个令牌，一秒钟转移一次，即从一台主机到另一台主机需要一秒。
3. 每台主机每隔6~16秒（随机选择一个时间）产生一次数据，此数据的目的主机号也是随机从8台主机中选择，内容为`Hello World`。
4. 要截获令牌之后才能够发送数据，否则要等待令牌到来。
5. 数据从一台主机到另一台主机需要1.5秒，发送方向和令牌环传播方向一致。
6. 使用图形界面来设置主机号，同时运行过程也通过图形界面来显示。

## 令牌环

令牌环通常用于局域网，它的特点是使用一种**三字节**长度的遍历一个环形网络，这个帧就称为令牌。令牌环技术位于OSI模型的第二层——数据链路层。

通过令牌环能够让每一个主机都有公平的几乎发送数据，消除了基于竞争的访问方法，解决了冲突问题。

再令牌环局域网中的主机被组织为一个环形网络，每一个主机都只能有序地向下一个主机发送数据，这个数据发送收到令牌的控制。

### 工作过程

数据发送过程如下：

* 一个空的数据帧（令牌）在环中传递。
* 当一台主机需要发送数据时，它就会接收令牌，然后这台主机将自己的数据帧（从结构上看，可以看成是在令牌帧之后添加了数据部分）发送出去。
* 数据帧将会被下一台主机验证，如果下一台主机发现这个数据帧的目的地址是自己，则它将复制数据帧中的内容，并修改帧状态。
* 当这个数据帧返回发送主机时，发送主机会查看帧状态查看是否被正确接收，若数据被正确接收，则将移除数据帧中的数据。（没有正确接收的情况我还不太清楚）
* 这台主机发送新的令牌（和旧的令牌其实是一样的），然后继续在环中循环。

### 帧格式

![令牌环帧格式](E:\Catalog\VitalFiles\Study\Course\计算机网络\img\令牌环帧格式.png)

#### 令牌

令牌长度为3个字节，包括**开始定界符、访问控制字节和结束定界符**。

| Start Delimiter | Access Control | End Delimiter |
| --------------- | -------------- | ------------- |
| 8-bits          | 8-bits         | 8-bits        |

#### 中断帧

用于要发送数据的主机中断令牌传送。

| SD     | ED     |
| ------ | ------ |
| 8-bits | 8-bits |

#### 数据字段

数据帧携带高层协议的信息，而命令帧只有控制信息而没有上层协议的数据。

数据（控制）帧的大小，取决于信息域（即上层协议的数据）的大小。

| SD     | AC     | FC     | DA      | SA      | PDU from LLC(IEEE 802.2) | CRC     | ED      | FS     |
| ------ | ------ | ------ | ------- | ------- | ------------------------ | ------- | ------- | ------ |
| 8-bits | 8-bits | 8-bits | 48-bits | 48-bits | up to 4500x8 bits        | 32-bits | 8- bits | 8-bits |

#### 开始定界符/结尾定界符

定界符是一个标识数据帧开头和结尾的一个1字节长度的控制字符。具体的位就不看了，明白这是标识一个帧的首尾的就行。

#### 访问控制（需要）

这个字段包括以下这几个位：

| +    | Bits 0-2 | 3     | 4       | 5-7         |
| ---- | -------- | ----- | ------- | ----------- |
| 0    | Priority | Token | Monitor | Reservation |

前三位为优先级，Token就是标识是否为令牌帧，Monitor是活动监视器（Active Monitor）主机设置的，如果它看到了这个帧，就说明环中有这个帧，否则说明令牌帧丢失。最后三位为保留位。

Token = 0，令牌；Token = 1， 控制/信息帧。

防止无效数据帧在环路中无限循环，帧发出时，M=0，第一次经过监控站时，M=1，若之后再次经过监控站，则删除这个帧，并发出令牌。

#### 帧控制

帧控制字段长度为一个字节。

这个字段指明当前帧的内容是否包括数据或控制信息。

在控制帧中，这个字节指明指明控制信息的种类。

| +    | Bits 0-1   | Bits 2-7     |
| ---- | ---------- | ------------ |
| 0    | Frame type | Control Bits |

Frame type-**01**表明当前帧为LLC帧（IEEE802.2）并且忽略控制位；

**00**标识为MAC帧并且控制帧指明MAC控制帧的类型。

#### 目的地址（需要）

六字节的字段用于指明目的主机的物理地址。

#### 源地址（需要）

包含发送数据的主机的物理地址，这是一个六字节的字段，这个字段可以是发送站适配器为本地分配地址LAA（Local Assigned Address）或者为全局分配地址UAA（Universally Assigned Address）。

#### 数据（需要）

是一个可变长字段，最大长度为4500字节。

#### 帧检验序列

是一个四字节长度的字段，使用CRC方法进行检验。

#### 帧状态（需要）

一字节长度的字段，用于检验数据帧是否被识别并且被接收方复制。

| A     | C     | 0     | 0     | A     | C     | 0     | 0     |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| 1-bit | 1-bit | 1-bit | 1-bit | 1-bit | 1-bit | 1-bit | 1-bit |

A=1，被识别

C=1，被复制

### 活动和就绪监视器

每一个在令牌环网络中的主机要么是一个活动监视器主机（Active Monitor，AM），要么是一个就绪监视器主机（Standby Monitor，SM）。

同一时刻只能有一个活动监视器。这个活动监视器通过**选举或者监视器争用过程**来选出。

当以下事件发生时监视器征用过程将被执行：

* 检测到环上的信号丢失。
* 一个活动监视器主机没有被另一个主机检测到。
* 一个计时器即将超时，比如一个站在7秒内都没有看到令牌。

当以上任何情况发生时，一个主机就会发现当前网络中需要一个AM，它就会发送一个宣言令牌，宣布它想成为新的AM。如果这个令牌返回了发送者，那么它就会成为新的AM；如果其他主机同一时刻也想成为AM，那么这些主机中具有最大MAC地址的将会赢得选举过程，其他所有竞选主机成为SM。如果必要的话，所有的主机都应当有能力称为AM。

AM有几个超级管理员功能。

第一个功能是作为主时钟为环上的主机提供信号同步。

第二个功能是为环插入24-bit的延迟，确保环中总是有足够的缓存保证令牌进行循环。

第三个功能是确保当没有帧传送时只有一个令牌在循环，并且检测环是否被打破。

最后一个功能是能够从环上移除令牌。

### 令牌插入程序

这一部分了解一下就好，我们这里不模拟这部分。

令牌环的主机必须经过5阶段的环插入过程才能加入到令牌环网络。如果任何一个阶段失败，令牌环的主机就不能加入到环网络并且令牌环驱动将会报告一个错误。

* 阶段0——叶检查

  一台主机先进行叶媒体检查，一个主机被封装在MSAU中并且能够发送2000个测试帧到它的发送对，然后再循环回到接受对，主机以此确保它可以无差错地收到这些帧。

* 阶段1——物理插入

  一台主机发送一个5V的信号到MSAU来开启继电器。

* 阶段2——地址确认

  在令牌环帧的目的地址字段中，工作站使用自己的MAC地址传输MAC帧。当这个帧返回时，如果其AR和FC位都为0（说明当前环中没有与之使用相同MAC地址的主机），该站必须参与周期性轮询过程。这时主机识别它们自己在网络中作为MAC管理功能的一部分。

* 阶段3——加入环轮询

  一个主机获取它活动上游邻居的地址，并将它自己的地址告诉最近的下游邻居，从而创建了环形地图。主机在收到AR和FC位都被设为0的AMP或SMP帧之前都会等待。当收到这种帧之后，如果资源充足，主机就会将AR和FC设置为1，并对SMP帧进行排队以进行传输。如果在18秒内都没有接收到这样一个帧，这个主机就会报告一个打开错误并从环中退出。如果这个站成功加参与环轮询，它就进入最后一个阶段，初始化请求。

* 阶段4——初始化请求

  最后一个站点向参数服务器发送一个特殊的请求来获取配置信息，这个帧被发送到一个特殊的功能地址，通常是一个令牌环桥，它可能包含定时器和这个新的主机需要知道的环号信息。

### 优先级（待定）

截获令牌时，优先级大于等于令牌内PPP的站点才能截获。

如果一台主机接收帧时发现目的地址不是自己，而且自己又有要发送的数据，则可以进行预约，将本站的优先级写入该帧的预约位（三位，一共7个优先级）。升高优先级的站点发送完数据后，要将令牌的优先等级降低为原来的优先级。

| Priority bits | Traffic type                                        |
| ------------- | --------------------------------------------------- |
| 000           | Normal data traffic                                 |
| 001           | Not used                                            |
| 010           | Not used                                            |
| 011           | Not used                                            |
| 100           | Normal data traffic（forwarded from other devices） |
| 101           | Data sent with time sensitivity requirements        |
| 110           | Data with real time sensitivity                     |
| 111           | Station management                                  |

## 线程与进程



## Socket基础

我们的令牌环的实现不需要什么高深的Socket技术，只需要掌握两点：Socket客户端和Socket服务器。

在开始之前，我们首先要知道两台主机之间是如何通信的。抛开计算机网络的多个模型，在我们的这个实现中，只考虑TCP/IP协议，当然，如果你不了解也没关系，我们的连接过程是面向TCP的，知道这个就可以了。

首先，计算机要通过一定的协议规则来进行通信，在这里基本思路就是，我们的计算机的某个应用要通过某个端口向外发送数据，而接收消息的计算机从相同的端口接收数据，我们怎么知道传递给哪个主机以及接收消息的主机怎么直到谁传给了呢？没错，我们还需要知道两台主机的IP地址。

我们说过，这里我们只用到TCP连接，即三次握手和四次握手的机制，这里不深入讨论。

知道这么个基本过程，我们就可以开始Socket编程了。

首先，Socket编程需要一方为服务器，一方为客户端，这里并不是说另一台主机一定是一个服务器，只不过他们的通信很像客户端-服务器通信。

数据有时怎么发送出去的呢？通过输入输出流。

客户端Socket创建输出流，将输出的数据写入，然后再发送给服务器Socket，服务器Socket创建输入流，接收来自客户端Socket的数据，然后它也可以创建一个输出流，将回复消息写入，发送给客户端Socket，再然后，客户端Socket创建一个输入流，接收来自服务器Socket的反馈。

这样，一次通信就完成了。至于进程之间的通信，可以学习一下操作系统。

明白了这些，我们的这次模拟实验就足够了。

当然，可以举个例子，这个例子是来自于网络的（因为我也不会啊）。

首先创建Client。

```java
package demo;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ConnectException;
import java.net.Socket;

public class Client {
    public static void main(String[] args) throws IOException {
        while(true) {
            try {
                // 创建客户端Socket，输入服务器的IP或者域名（这里是本地主机，所以localhost就可以了）和端口号
                Socket socket = new Socket("localhost", 8888);
                // 创建一个输出流
                PrintWriter os = new PrintWriter(socket.getOutputStream());
                // 写入内容：你好
                System.out.println("内容：你好");
                // os的写入方法有很多，可以学习《Java TCP/IP Socket编程》，也可以自行百度，这里写入字符串使用write就好
                os.write("你好");
                // 将缓冲区的内容送出
                os.flush();
                // 客户端Socket关闭输出
                socket.shutdownOutput();

                // 创建输入流
                InputStreamReader is = new InputStreamReader(socket.getInputStream());
                // 创建一个缓冲区，用于读，这样方便一些，直接通过is来读也未尝不可
                BufferedReader br = new BufferedReader(is);
                String info = null;
                while ((info = br.readLine()) != null) {
                    System.out.println("回应:" + info);
                }
                // 关闭流和缓冲区
                os.close();
                is.close();
                br.close();
                // 关闭Socket
                socket.close();
            }catch (ConnectException ce){ // 这个是防止你先运行了Client，后运行Server，如果这样就会报错，但是现在catch这个异常，就可以忽视这个错误
                continue;
            }
        }
    }
}

```

然后创建Server。

```java
package demo;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String args[]) throws IOException {
        while(true) {
            int port = 8888;
            String info = null;
            // 这里监听端口8888，如果Client发送数据，会发送到8888端口
            ServerSocket serverSocket = new ServerSocket(port);
            // 这里创建一个客户端Socket，调用ServerSocket.accept()返回向这个端口发送数据的客户端Socket
            Socket socket = serverSocket.accept();
            // 之后的内容和Cliend一样了，我就不多写了
            InputStreamReader is = new InputStreamReader(socket.getInputStream());
            BufferedReader br = new BufferedReader(is);
            while ((info = br.readLine()) != null) {
                System.out.println("内容:" + info);
            }
            socket.shutdownInput();
            PrintWriter os = new PrintWriter(socket.getOutputStream());
            os.write("Received");
            os.flush();
            socket.shutdownOutput();
            is.close();
            os.close();
            br.close();
            socket.close();
            serverSocket.close();
        }
    }

}
```

我们在IDEA中运行这两个程序，会产生两个进程（实际上应用层通信就是两个进程之间的通信）。

运行结果：

![Client运行结果](E:\Catalog\VitalFiles\Study\Course\计算机网络\img\Client运行结果.png)

![Server运行结果](E:\Catalog\VitalFiles\Study\Course\计算机网络\img\Server运行结果.png)

只有这些肯定还不够，我们还需要服务器保持长连接，使用线程监听，这样我们才能够建立起一个能够同时发送和接收数据的主机。

## Socket模拟令牌环运行

### 基本思路

我用的语言是Java，当然也可以用其他语言，思想是一样的，工具完全是建立在思想之上的，不要纠结于工具。

首先，我们要输入8个主机号，然后点击开始运行，开始运行之后就生成一个环型网络，然后开始令牌环模拟。

运用前面的例子，让一台主机既作为客户端Socket（后一台主机的客户端），也作为服务器Socket（前一台主机的服务器）。

要实现一个程序，最重要的是数据结构和算法。我们再讨论一下数据结构。

为了简单，我们按照前面给出的令牌帧和数据帧，去除掉一些字段，只使用我们需要的字段，这个后面再详细说一说。

算法其实没啥，主要内容就是令牌环的传递、产生和截获，数据的发送、接收和复制。

注意，我们需要一个主进程来作为展示，用它创建其他几个进程，其他几个进程还需要将自己的反馈信息发送给这个主进程。

这里就又来了个问题。我们需要创建进程，那么就需要调用其他几个进程的main函数。

这个问题其实困扰了我很久，我长话短说，就不说我出错的过程了，一些问题可以看最后的`Q&A`，这里我只说正确的做法。



### 数据结构

#### 消息

#### 主机进程

#### 主进程

### 主进程

主进程负责图形界面，并统筹所有主机的发送过程，比如现在主机A正在发送令牌环给B，就要从图形界面中展示出来，初步想法就是建立一个状态栏，显示状态，另外主进程还需要负责将我们输入的主机号发送给各个主机，然后各个主机初始化自己的主机号作为标识。

主进程作为一个总服务器，需要监听多个端口。

主进程中要设置监听线程，监听线程要不断地循环监听来自各个主机的消息，通过成员变量与主线程进行交流。

而发送线程不需要循环，只需要在有需要的时候发送一次即可。

#### 选择活动监视站

前面我们说，一个令牌环中必须要有一个活动监视站，用于监视是否有无效数据在传送，并且监视令牌环是否还存在。

按道理活动监视站是要竞选的，我们为了方便直接随机指定一个，因为竞选的过程比较复杂，我也不太了解具体的竞选流程。

活动监视站要能够做到生成令牌和删除令牌。

（当然还可以监测是否有无效数据帧，是否有令牌环等）。

注意：**我们这里的活动监视站，是选中的第一个发送令牌的主机**。

### 主机进程

主机进程需要完成的工作主要是，从主进程获取主机号并更新，如果自己有数据要发送，需要将这个消息发送给主进程，如果令牌环循环到此处或者数据到此处需要报告，如果自己获取到了数据也要报告，总而言之，就是各种情况都要向主进程报告。

另外主机进程还要自己生成数据，在随机的几秒内产生一个数据，然后等待，等自己接手令牌环后发送，另外这个数据的目的主机需要随机生成，我们将所有的主机号放在一个类当中，这个类使用单例模式，这样就会方便很多。

主机中也要设置监听线程和发送线程。

同样，监听线程要不断监听，有两个监听线程，一个负责监听主进程，另一个负责监听此主机的前一个主机进程。

注意，我们的主机需要四种线程：两个负责与主进程的消息交流，两个负责数据的接收和发送。

负责数据接收的线程在没有数据要发送的时候直接转发，不再回到主机进程，当有数据要发送时则改变某些状态位，不再转发，发送过程由主机进程操作。

当接收数据时，线程调用`copy`函数将数据帧复制到主机进程中的帧，模拟复制过程。

#### 数据产生与发送

数据由主机自己产生，当有数据时也可以继续产生数据，要设置一个**数据队列（仅存放目的主机号）**，新产生的数据要等待前面的数据发送完成。

数据发送前要检查是否有令牌，接收到令牌的时候检查自己的消息队列是否为空，如果不为空说明有数据要发送，此时将队列中第一个数据（实际上是一个主机号）取出，封装到数据帧中，然后发送给下一台主机。

发送完成后，要发送一个消息给主进程，告知我此时发送了一个数据。

之后每一台主机接收到数据帧，都要报告，直到某一台主机将数据复制到自己的缓冲区之后，剩下的主机报告*已被接受*。

当数据帧回到源主机时，检查是否被接受，并报告情况，然后发送令牌。

当接收到令牌时，也要向主进程发送消息，报告接收到令牌，有/无数据发送。

**我们将数据的各个字段封装在对象中**。

**此时Socket发送的不再是字符串而是对象了，可以使用json来操作，但是这个还要学习成本，所以我们这里实现对象Serializable，在这个类中设置一个serialVersionUID，然后就可以通过ObjectInputStream和ObjutOutputStream来读取和输出了**。

具体的实现方法看一下代码就明白了

#### 数据接收

数据接收时，按道理是要将数据复制到自己的缓冲区的，当然我们这里没办法实现两个过程：即查看和复制。我们这里全部都是读取出来，然后转发出去，接收时将数据复制到自己的接收数据中，然后发送数据，此时发送数据要检查接收数据是否为空，如果不为空则判断其是否为令牌，如果不是令牌，继续判断其源主机是否为自己，如果不是则直接转发。如果是令牌，则将自己的数据发送出去。

这里的接收数据非常重要，我们需要通过监听线程将监听到的数据保存到接收数据中，然后进行一系列判断之后新建发送线程。

#### 活动监视站

活动监视站的工作上面已经提到了，具体说一下实现流程。

主进程控制的开始模拟和重置模拟，需要与AM交流，这时候直接向以选为AM的主机通信即可。

而对于检测无效帧和令牌的操作，则需要

##### 生成令牌

生成令牌其实就是发送一个令牌帧，很容易。

##### 删除令牌

在图形界面中有一个删除令牌的按钮，点击后令牌到达活动监视站时由活动监视站删除（删除后要告知主进程，将活动监视站的主机号设为-1），此时系统中没有令牌，也没有了活动监视站。

之后必须重新点击开始运行，此时会新选择一个活动监视站。

## Q&A

#### Q：maven项目中，在类目录下使用命令`java ***`报错：找不到或无法加载主类

A：在IDEA的maven项目中，`.java`文件在IDEA中运行之后会自动将生成的`.class`放到`target\classes`中，当我们在`.java`文件目录下使用`java ***`会出错，应该到`target\classes`下运行。

另外还要注意一点，如果放入了包中，我们需要这样运行：`java packagename.***`，当前的目录应该位于包的上一个目录才可以。

这个问题会导致什么呢？

我们需要使用`Runtime`实例的`exec()`，在这里面我们需要用命令来运行进程，而我们要执行的类在`target\class`中，所以就需要到这个文件夹去运行。

简单来说，我们要通过程序加载某些文件或程序时，**要看编译后的路径**，而不是写代码的时候看到的路径。

#### Q：在IDEA中使用`Runtime.getRuntime().exec(cmd)`发现没有反应。

A：我们要创建多个进程，我们就一定要用到Runtime或者ProcessBuilder，但是我们使用的这个代码：

```java
Runtime.getRuntime().exec("java ***");
```

他的运行是不会出现任何反应的，而且运行这句话的进程在运行完这条语句之后如果没有其他语句，就会退出，但是如果打开的这个进程没有运行完，他就会一直在后台运行，为了能够看到这些进程，我们将命令改为：

```java
Runtime.getRuntime().exec("cmd /k start java ***");
```

这条语句的效果和上面的一样，但是他会打开cmd，如果我们的进程是一直运行的，他就会始终存在，如果出错的话，会一下子闪出错误信息然后退出（实际上快得看不清）。

所以运行这个程序的时候如果发现程序一闪而过，最好是检查一下Client和Server之间的关系是否正确，代码逻辑是否正确。

#### Q：Socket报告：java.net.SocketException:socket closed

A：这个问题是因为一个Socket如果输入输出流关闭就会自动关闭，因此关闭输入输出应该在最后，不要频繁关闭。

#### Q：Socket报告：java.net.SocketException:Connection reset

A：两种情况，（答案来自网络）第一个就是如果一端的Socket被关闭（或主动关闭或者因为异常退出而引起的关闭），另一端仍发送数据，发送的第一个数据包引发该异常(Connect reset by peer)。另一个是一端退出，但退出时并未关闭该连接，另一端如果在从连接中读数据则抛出该异常（Connection reset）。简单的说就是在连接断开后的读和写操作引起的。 

#### Q：我在主进程中更改了全局变量，而主机进程中检测不到。

A：这个问题很傻，这是两个进程，在这两个进程里全局变量的状态是不同的，除非将全局变量的值也传过去。

####  Q：直接发送一连串消息（枚举类型）给主进程时报错，`java.lang.ArrayIndexOutOfBoundsException`。

![枚举类型消息发送出错](E:\Catalog\VitalFiles\Study\Course\计算机网络\课程设计\img\枚举类型消息发送出错.png)

A：问题就在于，这里使用了线程，线程创建后是并发执行的，它们操作的还是同一个缓冲区，可能第一个线程在写入之后，还没有`flush`，第二个线程紧接着写进去，导致缓冲区的数据变得混乱不可分，这时候`flush`之后就会导致发送的数据出错（未知的错误，比如发送了错误的消息，或者数组越界，因为这里使用的枚举类型发送数据，从int转换为枚举使用的方法可能会造成数组越界）。

可以延时几秒再发送下一个，这样能够解决这个问题。

#### Q：在DataListener线程中改变了ProcessA中的某个状态变量，在DataSender中监测不到。

A：暂时还没找到原因。

#### Q：两个字符串使用`==`进行比较出错。

A：字符串内容的比较需要`equals`函数。

使用`==`是两个字符串的**引用**进行比较，判断是否指向同一个对象。

注意，如果两个字符串都是null，那么它们的`==`结果为`true`。

Java中使用的是文字池，有兴趣的可以自行学习一下。

#### Q：创建进程后没反应。

A：这个问题经常忘记，创建完进程还要`start()`才能够运行啊！

#### Q：通过`.class.getClassLoader.getResource().getPath()`无法正确得到路径，因为路径包含中文。

A：这种情况下得到的路径是有乱码的，它会将中文通过转义字符表示出来，这不是我们想要的。

要么将路径中的中文改成英文，或者使用`.class.getClassLoader.getResource().toURL().getPath()`，这种方式需要处理一个异常。



服务器打开接收的顺序问题